{"tagline":"Let's you cleanly, yet densely, visualize fMRI timecourses in R.","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"# TODO \r\n\r\n* Implement filter.rank and filter.score ...\r\n* Several of the scores need inverting\r\n* There are still no plot titles; WTF ggplot, WTF.\r\n* Correct errors in this doc\r\n\r\n# Install\r\nA set of R functions for sorting, filtering, and plotting of fMRI HRF timecourses.  The goal is make visualizing various properties of the timecourses simple, while producing clean, yet dense, displays.\r\n\r\nThe functions require plyr (http://plyr.had.co.nz/) and ggplot2 (http://ggplot2.org/), and have only been tested on R >= v2.15.1 (http://www.r-project.org/) on MacOS 10.7.4.\r\n\r\nTo use download this code, executing the following in the directory where you want the code installed.\r\n\r\n\tgit clone https://github.com/andsoandso/timecourse\r\n\r\nOr you can manually go to https://github.com/andsoandso/timecourse and click on the ZIP button to get the most recent version of the code.  Using git though will simplify updating the code in the future.\r\n\t\r\nThen open an R console and, assuming your working directory is ./timecourse, type\r\n\r\n\tsource(\"timecourse.R\")\r\n\r\n...In the future perhaps this will become a proper package, but for now you'll have to load everything manually.\r\n\r\n# Magic\r\n\r\nIf you just want to plot your data using all available scores and plot kinds, run:\r\n\r\n\t# read in the data, then plot it\r\n\tdata <- read.timecourse.rowformat('./test/roi_data_1.txt')\r\n\tplot.timecourse.magic(data,1,18,14)  # e.g. criterion=1,height=12, width=12\r\n\r\nWhere roi\\_data\\_1.txt is a text file of the form:\r\n\r\n\troi\t\tcondition\t1 \t2 \t \t...\tn\r\n\t1\t\tfast \t\t0.1\t0.3\t\t\t-.1\r\n\t\r\nWhere the first row is a header, and each subsequent row matches the corresponding data.  Thanks to plyr, very very large datasets can be handled relatively easily.\r\n\r\nEach of the magic plots is saved as pdf in the current working directory.  If you wish to keep only the top fraction of scores (which are described below), criterion can be set 0-1.  For example, if criterion=0.3 the top 30% of scores are plotted.\r\n\r\nTo see how magic works keep reading.\r\n\r\n# Details\r\n\r\nIf the magic is too much or too little, here are the details on the worker functions.  They can, mostly, be used alone just fine.\r\n\r\nAfter the loads above, a ls() will then reveal several useful functions; keep reading for the details.  The plotting functions are listed below.\r\n\t\r\n1. plot.timecourse.combinedconds\r\n2. [TODO] plot.timecourse.separateconds\r\n\r\nEach plotting function expects, one timecourse data_object, which is created as below.  The file in quotes is the test data set.\r\n\r\n\tdata_obj <- read.timecourse.rowformat('./test/roi_data_1.txt')\r\n\r\nNote: at current read.timecourse.* takes one data format, matching the format found in './test/roi\\_data\\_1.txt'.  This may change, if needed.\r\n\r\nThey also expect one score_object, created using score.timecourse(...).  As an example, if you wanted to score using the peak height, this would work:\r\n\r\n\tscore_obj <- score.timecourse(data_obj, \"peak\", score.peak)\r\n\r\nAs you can score.timecourse takes three arguments, a data_obj (from read.timecourse.rowformat), a name (i.e. \"peak\"), and a scoring function (making score.timecourse a metafunction).  \r\n\r\nThe available scoring functions are:\r\n\r\n1. score.peak - the max value\r\n2. score.mean - the mean value\r\n3. score.var - the variance\r\n4. score.absdiff - the absolute difference between the range value\r\n5. score.lag - time to max value\r\n6. score.halfmax - time to half the maximum (larger values imply steeper slopes)\r\n\r\nNote: If you have other scores in mind, ones not listed above, do share them. This code is designed to allow new scores to be added easily.\r\n\r\nOnce you have scores, they need to be ranked.  This is accomplished with\r\n\r\n\trank_object <- rank.score(scores, rank_means=TRUE)\r\n\t\r\nAnd these ranks are then applied to the timecourse data\r\n\r\n\tdata_ranked <- rank.timecourse(data_obj, rank_object, rank_means=TRUE)\r\n\r\nIn both cases above, rank_means is set to TRUE, as such the scores for any conditions (for each ROI) are averaged prior to ranking.\r\n\r\nIf there are too many ROIs, so you want to drop some based on rank do the below.  The criterion is between 0-1 (inclusive) and represents the top fraction of scores to keep, e.g. 0.1 would keep the top 10%.\r\n\r\n\tcriterion <- 0.1\r\n\tkeepers <- filter.rank(data_ranked, criterion)\r\n\r\n\t# Or as any rank-containing object will work\r\n\tkeepers <- filter.rank(ranked, criterion)\r\n\r\nOr you can filter the scores.  However unlike the rank filter you must specify the real valued threshold you want to use.\r\n\r\n\t# Assuming were working with peak scores, 0.5 (% signal change)\r\n\t# might be a reasonable choice\r\n\tthreshold <- 0.5\r\n\r\nNow explain how to use these and the direct plot methods in general","google":"","name":"Timecourse"}